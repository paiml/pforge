<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Complexity Limits - pforge: EXTREME TDD for MCP Servers</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Build production-ready MCP servers with EXTREME Test-Driven Development - 5-minute cycles, zero tolerance quality gates">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "rust";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pforge: EXTREME TDD for MCP Servers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paiml/pforge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/paiml/pforge/edit/main/pforge-book/src/ch08-03-complexity.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="complexity-analysis-keeping-functions-simple"><a class="header" href="#complexity-analysis-keeping-functions-simple">Complexity Analysis: Keeping Functions Simple</a></h1>
<p>Complex code kills projects. It hides bugs, slows development, and makes maintenance impossible. Studies show defect density increases exponentially with cyclomatic complexity—functions with complexity &gt; 20 are 10x more likely to contain bugs.</p>
<p>pforge enforces a strict complexity limit: <strong>cyclomatic complexity ≤ 20 per function</strong>. This isn’t arbitrary—it’s based on decades of software engineering research showing that complexity beyond this threshold makes code unmaintainable.</p>
<p>This chapter explains how complexity is measured, why it matters, how to identify complex code, and most importantly—how to simplify it.</p>
<h2 id="what-is-complexity"><a class="header" href="#what-is-complexity">What is Complexity?</a></h2>
<p>Complexity measures how hard code is to understand, test, and modify. pforge tracks two types:</p>
<h3 id="cyclomatic-complexity"><a class="header" href="#cyclomatic-complexity">Cyclomatic Complexity</a></h3>
<p><strong>Definition</strong>: The number of linearly independent paths through a function’s source code.</p>
<p><strong>Simplified calculation</strong>: Count the number of decision points (if, while, for, match, &amp;&amp;, ||) and add 1.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-rust">// Complexity: 1 (straight-line code, no decisions)
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// Complexity: 2 (one decision point)
fn abs(x: i32) -&gt; i32 {
    if x &lt; 0 {  // +1
        -x
    } else {
        x
    }
}

// Complexity: 4 (three decision points)
fn classify(age: i32) -&gt; &amp;'static str {
    if age &lt; 0 {          // +1
        "invalid"
    } else if age &lt; 13 {  // +1
        "child"
    } else if age &lt; 20 {  // +1
        "teenager"
    } else {
        "adult"
    }
}</code></pre>
<p>Each branch creates a new execution path. More paths = more complexity = more tests needed to cover all scenarios.</p>
<h3 id="cognitive-complexity"><a class="header" href="#cognitive-complexity">Cognitive Complexity</a></h3>
<p><strong>Definition</strong>: Measures how difficult code is for a human to understand.</p>
<p>Unlike cyclomatic complexity, cognitive complexity:</p>
<ul>
<li><strong>Penalizes nesting</strong>: Deeply nested code is harder to understand</li>
<li><strong>Ignores shorthand</strong>: <code>x &amp;&amp; y &amp;&amp; z</code> doesn’t add much cognitive load</li>
<li><strong>Rewards linear flow</strong>: Sequential code is easier than branching code</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-rust">// Cyclomatic: 4, Cognitive: 1
// Short-circuit evaluation is easy to understand
if x &amp;&amp; y &amp;&amp; z &amp;&amp; w {
    do_something();
}

// Cyclomatic: 4, Cognitive: 10
// Nesting increases cognitive load dramatically
if x {          // +1
    if y {      // +2 (nested once)
        if z {  // +3 (nested twice)
            if w { // +4 (nested three times)
                do_something();
            }
        }
    }
}</code></pre>
<p>Cognitive complexity better predicts how long it takes to understand code.</p>
<h2 id="why-complexity-matters"><a class="header" href="#why-complexity-matters">Why Complexity Matters</a></h2>
<h3 id="exponential-bug-density"><a class="header" href="#exponential-bug-density">Exponential Bug Density</a></h3>
<p>Research by McCabe (1976) and Basili &amp; Perricone (1984) shows:</p>
<div class="table-wrapper"><table><thead><tr><th>Cyclomatic Complexity</th><th>Defect Risk</th></tr></thead><tbody>
<tr><td>1-10</td><td>Low risk</td></tr>
<tr><td>11-20</td><td>Moderate risk</td></tr>
<tr><td>21-50</td><td>High risk</td></tr>
<tr><td>50+</td><td>Untestable</td></tr>
</tbody></table>
</div>
<p>Functions with complexity &gt; 20 have <strong>10x higher defect density</strong> than functions with complexity ≤ 10.</p>
<h3 id="testing-burden"><a class="header" href="#testing-burden">Testing Burden</a></h3>
<p>Cyclomatic complexity equals the minimum number of test cases needed for branch coverage:</p>
<pre><code class="language-rust">// Complexity: 5
// Requires 5 test cases for full branch coverage
fn validate(input: &amp;str) -&gt; Result&lt;(), String&gt; {
    if input.is_empty() {           // Test case 1
        return Err("empty".into());
    }
    if input.len() &gt; 100 {          // Test case 2
        return Err("too long".into());
    }
    if !input.chars().all(|c| c.is_alphanumeric()) { // Test case 3
        return Err("invalid chars".into());
    }
    match input.chars().next() {
        Some('0'..='9') =&gt; Err("starts with digit".into()), // Test case 4
        _ =&gt; Ok(())                 // Test case 5
    }
}</code></pre>
<p>Complexity 20 requires 20 test cases. Complexity 50 requires 50. High complexity makes thorough testing impractical.</p>
<h3 id="comprehension-time"><a class="header" href="#comprehension-time">Comprehension Time</a></h3>
<p>Studies show developers take exponentially longer to understand complex code:</p>
<ul>
<li>Complexity 1-5: <strong>2-5 minutes</strong> to understand</li>
<li>Complexity 6-10: <strong>10-20 minutes</strong> to understand</li>
<li>Complexity 11-20: <strong>30-60 minutes</strong> to understand</li>
<li>Complexity &gt; 20: <strong>Hours or days</strong> to understand fully</li>
</ul>
<p>When onboarding new developers or debugging in production, comprehension speed matters.</p>
<h3 id="modification-risk"><a class="header" href="#modification-risk">Modification Risk</a></h3>
<p>Making changes to complex code is dangerous:</p>
<ul>
<li><strong>Hard to predict side effects</strong>: Many execution paths mean many places where changes can break things</li>
<li><strong>Refactoring is risky</strong>: You can’t test all paths, so refactors might introduce bugs</li>
<li><strong>Fear of touching code</strong>: Developers avoid modifying complex functions, leading to workarounds and more complexity</li>
</ul>
<h2 id="measuring-complexity"><a class="header" href="#measuring-complexity">Measuring Complexity</a></h2>
<h3 id="using-pmat"><a class="header" href="#using-pmat">Using PMAT</a></h3>
<p>Run complexity analysis on your codebase:</p>
<pre><code class="language-bash">pmat analyze complexity --max-cyclomatic 20 --format summary
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code># Complexity Analysis Summary

📊 **Files analyzed**: 23
🔧 **Total functions**: 187

## Complexity Metrics

- **Median Cyclomatic**: 3.0
- **Median Cognitive**: 2.0
- **Max Cyclomatic**: 12
- **Max Cognitive**: 15
- **90th Percentile Cyclomatic**: 8
- **90th Percentile Cognitive**: 10

## Violations (0)

✅ All functions within complexity limits (max cyclomatic: 20)
</code></pre>
<p>Healthy codebase:</p>
<ul>
<li><strong>Median &lt; 5</strong>: Most functions are simple</li>
<li><strong>Max &lt; 15</strong>: Even the most complex functions are manageable</li>
<li><strong>90th percentile &lt; 10</strong>: Only 10% of functions have complexity &gt; 10</li>
</ul>
<h3 id="detailed-analysis"><a class="header" href="#detailed-analysis">Detailed Analysis</a></h3>
<p>For violations, get detailed output:</p>
<pre><code class="language-bash">pmat analyze complexity --max-cyclomatic 20 --format detailed
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>❌ Function 'process_request' exceeds cyclomatic complexity
   Location: src/handler.rs:156
   Cyclomatic: 24 (max: 20)
   Cognitive: 19

   Breakdown:
   - 8 if statements (4 nested)
   - 3 match expressions
   - 2 for loops
   - 1 while loop

   Recommendations:
   1. Extract validation logic (lines 165-190) → validate_request()
   2. Extract error handling (lines 205-240) → handle_errors()
   3. Use early returns to reduce nesting (lines 250-280)
   4. Replace if-else chain (lines 300-350) with match expression
</code></pre>
<p>PMAT identifies exactly where complexity comes from and suggests fixes.</p>
<h3 id="per-file-analysis"><a class="header" href="#per-file-analysis">Per-File Analysis</a></h3>
<p>Analyze a specific file:</p>
<pre><code class="language-bash">pmat analyze complexity src/handler.rs
</code></pre>
<p>Track complexity during development to catch issues early.</p>
<h2 id="identifying-complex-code"><a class="header" href="#identifying-complex-code">Identifying Complex Code</a></h2>
<h3 id="red-flags"><a class="header" href="#red-flags">Red Flags</a></h3>
<p><strong>1. Deep Nesting</strong></p>
<pre><code class="language-rust">// BAD: Nesting level 5
fn process(data: &amp;Data) -&gt; Result&lt;String&gt; {
    if data.is_valid() {
        if let Some(user) = data.user() {
            if user.is_active() {
                if let Some(perms) = user.permissions() {
                    if perms.can_read() {
                        // Actual logic buried 5 levels deep
                        return Ok(data.content());
                    }
                }
            }
        }
    }
    Err("Invalid")
}</code></pre>
<p>Each nesting level adds cognitive load.</p>
<p><strong>2. Long Match Expressions</strong></p>
<pre><code class="language-rust">// BAD: 15 arms
match command {
    Command::Create =&gt; handle_create(),
    Command::Read =&gt; handle_read(),
    Command::Update =&gt; handle_update(),
    Command::Delete =&gt; handle_delete(),
    Command::List =&gt; handle_list(),
    Command::Search =&gt; handle_search(),
    Command::Filter =&gt; handle_filter(),
    Command::Sort =&gt; handle_sort(),
    Command::Export =&gt; handle_export(),
    Command::Import =&gt; handle_import(),
    Command::Validate =&gt; handle_validate(),
    Command::Transform =&gt; handle_transform(),
    Command::Aggregate =&gt; handle_aggregate(),
    Command::Analyze =&gt; handle_analyze(),
    Command::Report =&gt; handle_report(),
}</code></pre>
<p>Each match arm is a decision point. 15 arms = complexity 15.</p>
<p><strong>3. Boolean Logic Soup</strong></p>
<pre><code class="language-rust">// BAD: Complex boolean expression
if (user.is_admin() || user.is_moderator()) &amp;&amp;
   !user.is_banned() &amp;&amp;
   (resource.is_public() || resource.owner() == user.id()) &amp;&amp;
   (time.is_business_hours() || user.has_permission("after_hours")) &amp;&amp;
   !system.is_maintenance_mode() {
    // Allow access
}</code></pre>
<p>Each <code>&amp;&amp;</code> and <code>||</code> adds complexity. This expression has cyclomatic complexity 6 just for the condition.</p>
<p><strong>4. Loop-within-Loop</strong></p>
<pre><code class="language-rust">// BAD: Nested loops with conditions
for user in users {
    if user.is_active() {
        for item in user.items() {
            if item.needs_processing() {
                for dep in item.dependencies() {
                    if dep.is_ready() {
                        process(dep);
                    }
                }
            }
        }
    }
}</code></pre>
<p>Nested loops with conditionals create exponential complexity.</p>
<p><strong>5. Error Handling Maze</strong></p>
<pre><code class="language-rust">// BAD: Error handling everywhere
fn complex_operation() -&gt; Result&lt;String&gt; {
    let a = step1().map_err(|e| Error::Step1(e))?;

    if a.needs_validation() {
        validate(&amp;a).map_err(|e| Error::Validation(e))?;
    }

    let b = if a.has_data() {
        step2(&amp;a).map_err(|e| Error::Step2(e))?
    } else {
        default_value()
    };

    match step3(&amp;b) {
        Ok(c) =&gt; {
            if c.is_complete() {
                Ok(c.value())
            } else {
                Err(Error::Incomplete)
            }
        }
        Err(e) =&gt; {
            if can_retry(&amp;e) {
                retry_step3(&amp;b)
            } else {
                Err(Error::Step3(e))
            }
        }
    }
}</code></pre>
<p>Complexity 12 from error handling alone.</p>
<h2 id="reducing-complexity"><a class="header" href="#reducing-complexity">Reducing Complexity</a></h2>
<h3 id="strategy-1-extract-functions"><a class="header" href="#strategy-1-extract-functions">Strategy 1: Extract Functions</a></h3>
<p><strong>Before</strong> (complexity 24):</p>
<pre><code class="language-rust">fn process_request(req: &amp;Request) -&gt; Result&lt;Response&gt; {
    // Validation (complexity +8)
    if req.user.is_empty() {
        return Err(Error::NoUser);
    }
    if req.user.len() &gt; 100 {
        return Err(Error::UserTooLong);
    }
    if !req.user.chars().all(|c| c.is_alphanumeric()) {
        return Err(Error::InvalidUser);
    }
    if req.action.is_empty() {
        return Err(Error::NoAction);
    }

    // Authorization (complexity +6)
    let user = db.get_user(&amp;req.user)?;
    if !user.is_active() {
        return Err(Error::Inactive);
    }
    if user.is_banned() {
        return Err(Error::Banned);
    }
    if !user.has_permission(&amp;req.action) {
        return Err(Error::Forbidden);
    }

    // Processing (complexity +10)
    let result = match req.action.as_str() {
        "read" =&gt; db.read(&amp;req.resource),
        "write" =&gt; db.write(&amp;req.resource, &amp;req.data),
        "delete" =&gt; db.delete(&amp;req.resource),
        "list" =&gt; db.list(&amp;req.filter),
        // ... 6 more cases
        _ =&gt; Err(Error::UnknownAction)
    }?;

    Ok(Response::new(result))
}</code></pre>
<p><strong>After</strong> (complexity 4):</p>
<pre><code class="language-rust">fn process_request(req: &amp;Request) -&gt; Result&lt;Response&gt; {
    validate_request(req)?;          // +1
    let user = authorize_request(req)?;  // +1
    let result = execute_action(req, &amp;user)?; // +1
    Ok(Response::new(result))        // +1
}

fn validate_request(req: &amp;Request) -&gt; Result&lt;()&gt; {
    // Complexity 8 isolated in this function
    if req.user.is_empty() {
        return Err(Error::NoUser);
    }
    if req.user.len() &gt; 100 {
        return Err(Error::UserTooLong);
    }
    if !req.user.chars().all(|c| c.is_alphanumeric()) {
        return Err(Error::InvalidUser);
    }
    if req.action.is_empty() {
        return Err(Error::NoAction);
    }
    Ok(())
}

fn authorize_request(req: &amp;Request) -&gt; Result&lt;User&gt; {
    // Complexity 6 isolated here
    let user = db.get_user(&amp;req.user)?;
    if !user.is_active() {
        return Err(Error::Inactive);
    }
    if user.is_banned() {
        return Err(Error::Banned);
    }
    if !user.has_permission(&amp;req.action) {
        return Err(Error::Forbidden);
    }
    Ok(user)
}

fn execute_action(req: &amp;Request, user: &amp;User) -&gt; Result&lt;String&gt; {
    // Complexity 10 isolated here
    match req.action.as_str() {
        "read" =&gt; db.read(&amp;req.resource),
        "write" =&gt; db.write(&amp;req.resource, &amp;req.data),
        "delete" =&gt; db.delete(&amp;req.resource),
        // ...
        _ =&gt; Err(Error::UnknownAction)
    }
}</code></pre>
<p><strong>Result</strong>: Main function complexity drops from 24 to 4. Helper functions each have manageable complexity.</p>
<h3 id="strategy-2-early-returns-guard-clauses"><a class="header" href="#strategy-2-early-returns-guard-clauses">Strategy 2: Early Returns (Guard Clauses)</a></h3>
<p><strong>Before</strong> (complexity 7, cognitive 10):</p>
<pre><code class="language-rust">fn process(user: &amp;User, data: &amp;Data) -&gt; Result&lt;String&gt; {
    if user.is_active() {
        if !user.is_banned() {
            if user.has_permission("read") {
                if data.is_valid() {
                    if !data.is_expired() {
                        return Ok(data.content());
                    }
                }
            }
        }
    }
    Err(Error::Forbidden)
}</code></pre>
<p><strong>After</strong> (complexity 7, cognitive 5):</p>
<pre><code class="language-rust">fn process(user: &amp;User, data: &amp;Data) -&gt; Result&lt;String&gt; {
    if !user.is_active() {
        return Err(Error::Inactive);
    }
    if user.is_banned() {
        return Err(Error::Banned);
    }
    if !user.has_permission("read") {
        return Err(Error::Forbidden);
    }
    if !data.is_valid() {
        return Err(Error::InvalidData);
    }
    if data.is_expired() {
        return Err(Error::Expired);
    }

    Ok(data.content())
}</code></pre>
<p><strong>Result</strong>: Same cyclomatic complexity, but cognitive complexity reduced from 10 to 5. Code is linear and easy to follow.</p>
<h3 id="strategy-3-replace-nested-if-with-match"><a class="header" href="#strategy-3-replace-nested-if-with-match">Strategy 3: Replace Nested If with Match</a></h3>
<p><strong>Before</strong> (complexity 8):</p>
<pre><code class="language-rust">fn classify_status(code: i32) -&gt; &amp;'static str {
    if code &gt;= 200 {
        if code &lt; 300 {
            "success"
        } else if code &gt;= 300 {
            if code &lt; 400 {
                "redirect"
            } else if code &gt;= 400 {
                if code &lt; 500 {
                    "client_error"
                } else {
                    "server_error"
                }
            } else {
                "unknown"
            }
        } else {
            "unknown"
        }
    } else {
        "informational"
    }
}</code></pre>
<p><strong>After</strong> (complexity 5):</p>
<pre><code class="language-rust">fn classify_status(code: i32) -&gt; &amp;'static str {
    match code {
        100..=199 =&gt; "informational",
        200..=299 =&gt; "success",
        300..=399 =&gt; "redirect",
        400..=499 =&gt; "client_error",
        500..=599 =&gt; "server_error",
        _ =&gt; "unknown"
    }
}</code></pre>
<p><strong>Result</strong>: Complexity drops from 8 to 5. Code is clearer and more maintainable.</p>
<h3 id="strategy-4-use-rusts--operator"><a class="header" href="#strategy-4-use-rusts--operator">Strategy 4: Use Rust’s <code>?</code> Operator</a></h3>
<p><strong>Before</strong> (complexity 10):</p>
<pre><code class="language-rust">fn load_config() -&gt; Result&lt;Config&gt; {
    let file = match File::open("config.yaml") {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(Error::FileOpen(e))
    };

    let mut contents = String::new();
    if let Err(e) = file.read_to_string(&amp;mut contents) {
        return Err(Error::FileRead(e));
    }

    let config: Config = match serde_yaml::from_str(&amp;contents) {
        Ok(c) =&gt; c,
        Err(e) =&gt; return Err(Error::Parse(e))
    };

    if config.validate().is_err() {
        return Err(Error::Invalid);
    }

    Ok(config)
}</code></pre>
<p><strong>After</strong> (complexity 3):</p>
<pre><code class="language-rust">fn load_config() -&gt; Result&lt;Config&gt; {
    let mut file = File::open("config.yaml")
        .map_err(Error::FileOpen)?;

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)
        .map_err(Error::FileRead)?;

    let config: Config = serde_yaml::from_str(&amp;contents)
        .map_err(Error::Parse)?;

    config.validate()
        .map_err(|_| Error::Invalid)?;

    Ok(config)
}</code></pre>
<p><strong>Result</strong>: Complexity drops from 10 to 3 by leveraging <code>?</code> operator.</p>
<h3 id="strategy-5-extract-complex-conditions"><a class="header" href="#strategy-5-extract-complex-conditions">Strategy 5: Extract Complex Conditions</a></h3>
<p><strong>Before</strong> (complexity 8):</p>
<pre><code class="language-rust">fn should_process(user: &amp;User, resource: &amp;Resource, time: &amp;Time) -&gt; bool {
    (user.is_admin() || user.is_moderator()) &amp;&amp;
    !user.is_banned() &amp;&amp;
    (resource.is_public() || resource.owner() == user.id()) &amp;&amp;
    (time.is_business_hours() || user.has_permission("after_hours")) &amp;&amp;
    !system.is_maintenance_mode()
}</code></pre>
<p><strong>After</strong> (complexity 4):</p>
<pre><code class="language-rust">fn should_process(user: &amp;User, resource: &amp;Resource, time: &amp;Time) -&gt; bool {
    has_required_role(user) &amp;&amp;
    can_access_resource(user, resource) &amp;&amp;
    is_allowed_time(user, time) &amp;&amp;
    !system.is_maintenance_mode()
}

fn has_required_role(user: &amp;User) -&gt; bool {
    (user.is_admin() || user.is_moderator()) &amp;&amp; !user.is_banned()
}

fn can_access_resource(user: &amp;User, resource: &amp;Resource) -&gt; bool {
    resource.is_public() || resource.owner() == user.id()
}

fn is_allowed_time(user: &amp;User, time: &amp;Time) -&gt; bool {
    time.is_business_hours() || user.has_permission("after_hours")
}</code></pre>
<p><strong>Result</strong>: Complexity drops from 8 to 4. Named functions document what each condition means.</p>
<h3 id="strategy-6-polymorphism-strategy-pattern"><a class="header" href="#strategy-6-polymorphism-strategy-pattern">Strategy 6: Polymorphism (Strategy Pattern)</a></h3>
<p><strong>Before</strong> (complexity 15):</p>
<pre><code class="language-rust">fn handle_command(cmd: &amp;Command) -&gt; Result&lt;Response&gt; {
    match cmd.type {
        "create" =&gt; {
            validate_create(&amp;cmd.data)?;
            db.create(&amp;cmd.data)
        }
        "read" =&gt; {
            validate_read(&amp;cmd.id)?;
            db.read(&amp;cmd.id)
        }
        "update" =&gt; {
            validate_update(&amp;cmd.id, &amp;cmd.data)?;
            db.update(&amp;cmd.id, &amp;cmd.data)
        }
        "delete" =&gt; {
            validate_delete(&amp;cmd.id)?;
            db.delete(&amp;cmd.id)
        }
        // 11 more cases...
        _ =&gt; Err(Error::Unknown)
    }
}</code></pre>
<p><strong>After</strong> (complexity 2):</p>
<pre><code class="language-rust">trait CommandHandler {
    fn validate(&amp;self) -&gt; Result&lt;()&gt;;
    fn execute(&amp;self) -&gt; Result&lt;Response&gt;;
}

struct CreateCommand { data: Data }
impl CommandHandler for CreateCommand {
    fn validate(&amp;self) -&gt; Result&lt;()&gt; { validate_create(&amp;self.data) }
    fn execute(&amp;self) -&gt; Result&lt;Response&gt; { db.create(&amp;self.data) }
}

// Similar impls for Read, Update, Delete, etc.

fn handle_command(cmd: Box&lt;dyn CommandHandler&gt;) -&gt; Result&lt;Response&gt; {
    cmd.validate()?;
    cmd.execute()
}</code></pre>
<p><strong>Result</strong>: Complexity drops from 15 to 2. Each command is isolated in its own type.</p>
<h2 id="complexity-in-practice"><a class="header" href="#complexity-in-practice">Complexity in Practice</a></h2>
<h3 id="example-refactoring-a-complex-function"><a class="header" href="#example-refactoring-a-complex-function">Example: Refactoring a Complex Function</a></h3>
<p><strong>Initial state</strong> (complexity 28):</p>
<pre><code class="language-rust">fn authenticate_and_authorize(
    req: &amp;Request,
    db: &amp;Database,
    cache: &amp;Cache
) -&gt; Result&lt;User&gt; {
    // Validation
    if req.token.is_empty() {
        return Err(Error::NoToken);
    }

    // Check cache
    if let Some(cached) = cache.get(&amp;req.token) {
        if !cached.is_expired() {
            if cached.user.is_active() {
                if !cached.user.is_banned() {
                    if cached.user.has_permission(&amp;req.action) {
                        return Ok(cached.user.clone());
                    }
                }
            }
        }
    }

    // Parse token
    let claims = match jwt::decode(&amp;req.token) {
        Ok(c) =&gt; c,
        Err(e) =&gt; {
            if e.kind() == jwt::ErrorKind::Expired {
                return Err(Error::TokenExpired);
            } else {
                return Err(Error::InvalidToken);
            }
        }
    };

    // Load user
    let user = db.get_user(claims.user_id)?;

    // Validate user
    if !user.is_active() {
        return Err(Error::UserInactive);
    }
    if user.is_banned() {
        return Err(Error::UserBanned);
    }
    if !user.has_permission(&amp;req.action) {
        return Err(Error::Forbidden);
    }

    // Update cache
    cache.set(&amp;req.token, CachedAuth {
        user: user.clone(),
        expires_at: Time::now() + Duration::hours(1)
    });

    Ok(user)
}</code></pre>
<p><strong>Refactored</strong> (main function complexity 4):</p>
<pre><code class="language-rust">fn authenticate_and_authorize(
    req: &amp;Request,
    db: &amp;Database,
    cache: &amp;Cache
) -&gt; Result&lt;User&gt; {
    validate_request(req)?;

    if let Some(user) = check_cache(req, cache)? {
        return Ok(user);
    }

    let claims = parse_token(&amp;req.token)?;
    let user = load_and_validate_user(claims.user_id, &amp;req.action, db)?;
    update_cache(&amp;req.token, &amp;user, cache);

    Ok(user)
}

fn validate_request(req: &amp;Request) -&gt; Result&lt;()&gt; {
    if req.token.is_empty() {
        return Err(Error::NoToken);
    }
    Ok(())
}

fn check_cache(req: &amp;Request, cache: &amp;Cache) -&gt; Result&lt;Option&lt;User&gt;&gt; {
    if let Some(cached) = cache.get(&amp;req.token) {
        if cached.is_expired() {
            return Ok(None);
        }

        validate_user_access(&amp;cached.user, &amp;req.action)?;
        return Ok(Some(cached.user.clone()));
    }

    Ok(None)
}

fn parse_token(token: &amp;str) -&gt; Result&lt;Claims&gt; {
    jwt::decode(token).map_err(|e| {
        match e.kind() {
            jwt::ErrorKind::Expired =&gt; Error::TokenExpired,
            _ =&gt; Error::InvalidToken
        }
    })
}

fn load_and_validate_user(
    user_id: UserId,
    action: &amp;str,
    db: &amp;Database
) -&gt; Result&lt;User&gt; {
    let user = db.get_user(user_id)?;
    validate_user_access(&amp;user, action)?;
    Ok(user)
}

fn validate_user_access(user: &amp;User, action: &amp;str) -&gt; Result&lt;()&gt; {
    if !user.is_active() {
        return Err(Error::UserInactive);
    }
    if user.is_banned() {
        return Err(Error::UserBanned);
    }
    if !user.has_permission(action) {
        return Err(Error::Forbidden);
    }
    Ok(())
}

fn update_cache(token: &amp;str, user: &amp;User, cache: &amp;Cache) {
    cache.set(token, CachedAuth {
        user: user.clone(),
        expires_at: Time::now() + Duration::hours(1)
    });
}</code></pre>
<p><strong>Result</strong>:</p>
<ul>
<li>Main function: 28 → 4 (85% reduction)</li>
<li>All helper functions: &lt; 10 complexity</li>
<li>Code is testable, readable, maintainable</li>
</ul>
<h3 id="when-complexity-is-unavoidable"><a class="header" href="#when-complexity-is-unavoidable">When Complexity is Unavoidable</a></h3>
<p>Sometimes high complexity is inherent to the problem:</p>
<pre><code class="language-rust">// Parser for complex grammar - complexity 25
fn parse_expression(tokens: &amp;[Token]) -&gt; Result&lt;Expr&gt; {
    // Inherently complex: operator precedence, associativity,
    // parentheses, function calls, array access, etc.
    // This complexity reflects problem complexity, not poor design
}</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Accept it, but document</strong>: Add extensive comments explaining the logic</li>
<li><strong>Comprehensive tests</strong>: Ensure every path is tested</li>
<li><strong>Isolate it</strong>: Keep complex logic in dedicated modules</li>
<li><strong>Consider alternatives</strong>: Maybe a parser generator library would simplify this</li>
</ol>
<h2 id="tracking-complexity-trends"><a class="header" href="#tracking-complexity-trends">Tracking Complexity Trends</a></h2>
<p>Monitor complexity over time:</p>
<pre><code class="language-bash"># Daily complexity snapshot
echo "$(date),$(pmat analyze complexity --format json | jq -r '.max_cyclomatic')" &gt;&gt; complexity.csv
</code></pre>
<p>Plot trends to catch regressions early:</p>
<pre><code class="language-bash"># Visualize complexity trends
gnuplot &lt;&lt; EOF
set terminal png size 800,600
set output 'complexity-trend.png'
set xlabel 'Date'
set ylabel 'Max Cyclomatic Complexity'
set datafile separator ","
set xdata time
set timefmt "%Y-%m-%d"
plot 'complexity.csv' using 1:2 with lines title 'Max Complexity'
EOF
</code></pre>
<p>If max complexity trends upward, intervene before it exceeds 20.</p>
<h2 id="complexity-budget"><a class="header" href="#complexity-budget">Complexity Budget</a></h2>
<p>Treat complexity like memory or performance—you have a budget:</p>
<p><strong>Project-level budget</strong>:</p>
<ul>
<li>Total cyclomatic complexity for all functions: <strong>&lt; 500</strong></li>
<li>Median complexity: <strong>&lt; 5</strong></li>
<li>Max complexity: <strong>&lt; 20</strong></li>
</ul>
<p>If adding a new function would exceed the budget, refactor existing code first.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Complexity kills maintainability. pforge enforces cyclomatic complexity ≤ 20 per function to prevent unmaintainable code.</p>
<p><strong>Key techniques to reduce complexity</strong>:</p>
<ol>
<li><strong>Extract functions</strong>: Break large functions into focused helpers</li>
<li><strong>Early returns</strong>: Replace nesting with guard clauses</li>
<li><strong>Use match</strong>: Replace nested if-else with pattern matching</li>
<li><strong>Leverage <code>?</code></strong>: Simplify error handling</li>
<li><strong>Extract conditions</strong>: Give complex boolean expressions names</li>
<li><strong>Polymorphism</strong>: Replace switch/match with trait dispatch</li>
</ol>
<p><strong>Complexity thresholds</strong>:</p>
<ul>
<li><strong>1-5</strong>: Simple, ideal</li>
<li><strong>6-10</strong>: Moderate, acceptable</li>
<li><strong>11-20</strong>: Complex, refactor when possible</li>
<li><strong>&gt; 20</strong>: Exceeds pforge limit, must refactor</li>
</ul>
<p>The next chapter covers <strong>code coverage</strong>, showing how to ensure your tests actually test the code you write.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-02-pmat.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-04-coverage.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-02-pmat.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-04-coverage.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
