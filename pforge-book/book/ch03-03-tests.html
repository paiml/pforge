<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unit Tests - pforge: EXTREME TDD for MCP Servers</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Build production-ready MCP servers with EXTREME Test-Driven Development - 5-minute cycles, zero tolerance quality gates">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "rust";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pforge: EXTREME TDD for MCP Servers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paiml/pforge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/paiml/pforge/edit/main/pforge-book/src/ch03-03-tests.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="testing-the-calculator-extreme-tdd-in-action"><a class="header" href="#testing-the-calculator-extreme-tdd-in-action">Testing the Calculator: EXTREME TDD in Action</a></h1>
<p>The calculator has <strong>six tests</strong> that provide 100% code coverage and demonstrate every principle of EXTREME TDD. Let’s examine each test and the discipline that produced them.</p>
<h2 id="the-complete-test-suite"><a class="header" href="#the-complete-test-suite">The Complete Test Suite</a></h2>
<p>All tests live in <code>src/handlers.rs</code> under the <code>#[cfg(test)]</code> module:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_add() {
        let handler = CalculateHandler;
        let input = CalculateInput {
            operation: "add".to_string(),
            a: 5.0,
            b: 3.0,
        };

        let output = handler.handle(input).await.unwrap();
        assert_eq!(output.result, 8.0);
    }

    #[tokio::test]
    async fn test_subtract() {
        let handler = CalculateHandler;
        let input = CalculateInput {
            operation: "subtract".to_string(),
            a: 10.0,
            b: 3.0,
        };

        let output = handler.handle(input).await.unwrap();
        assert_eq!(output.result, 7.0);
    }

    #[tokio::test]
    async fn test_multiply() {
        let handler = CalculateHandler;
        let input = CalculateInput {
            operation: "multiply".to_string(),
            a: 4.0,
            b: 5.0,
        };

        let output = handler.handle(input).await.unwrap();
        assert_eq!(output.result, 20.0);
    }

    #[tokio::test]
    async fn test_divide() {
        let handler = CalculateHandler;
        let input = CalculateInput {
            operation: "divide".to_string(),
            a: 15.0,
            b: 3.0,
        };

        let output = handler.handle(input).await.unwrap();
        assert_eq!(output.result, 5.0);
    }

    #[tokio::test]
    async fn test_divide_by_zero() {
        let handler = CalculateHandler;
        let input = CalculateInput {
            operation: "divide".to_string(),
            a: 10.0,
            b: 0.0,
        };

        let result = handler.handle(input).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Division by zero"));
    }

    #[tokio::test]
    async fn test_unknown_operation() {
        let handler = CalculateHandler;
        let input = CalculateInput {
            operation: "modulo".to_string(),
            a: 10.0,
            b: 3.0,
        };

        let result = handler.handle(input).await;
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Unknown operation"));
    }
}</code></pre>
<h2 id="test-anatomy"><a class="header" href="#test-anatomy">Test Anatomy</a></h2>
<p>Every test follows this <strong>four-part structure</strong>:</p>
<h3 id="1-setup-arrange"><a class="header" href="#1-setup-arrange">1. Setup (Arrange)</a></h3>
<pre><code class="language-rust">let handler = CalculateHandler;
let input = CalculateInput {
    operation: "add".to_string(),
    a: 5.0,
    b: 3.0,
};</code></pre>
<p><strong>Why create handler locally?</strong></p>
<ul>
<li>Each test is independent (no shared state)</li>
<li>Tests can run in parallel</li>
<li>No test pollution</li>
</ul>
<h3 id="2-execution-act"><a class="header" href="#2-execution-act">2. Execution (Act)</a></h3>
<pre><code class="language-rust">let output = handler.handle(input).await.unwrap();</code></pre>
<p><strong>Key decisions</strong>:</p>
<ul>
<li><code>.await</code>: Handler is async (returns Future)</li>
<li><code>.unwrap()</code>: For happy path tests, we expect success</li>
<li>Store result for assertion</li>
</ul>
<h3 id="3-verification-assert"><a class="header" href="#3-verification-assert">3. Verification (Assert)</a></h3>
<pre><code class="language-rust">assert_eq!(output.result, 8.0);</code></pre>
<p><strong>Assertion strategies</strong>:</p>
<ul>
<li><code>assert_eq!</code>: For exact values (happy path)</li>
<li><code>assert!()</code>: For boolean conditions (error path)</li>
<li><code>.contains()</code>: For error message validation</li>
</ul>
<h3 id="4-cleanup-automatic"><a class="header" href="#4-cleanup-automatic">4. Cleanup (Automatic)</a></h3>
<p>Rust’s RAII means cleanup is automatic - no manual teardown needed.</p>
<h2 id="the-six-tests-explained"><a class="header" href="#the-six-tests-explained">The Six Tests Explained</a></h2>
<h3 id="test-1-addition-happy-path"><a class="header" href="#test-1-addition-happy-path">Test 1: Addition (Happy Path)</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_add() {
    let handler = CalculateHandler;
    let input = CalculateInput {
        operation: "add".to_string(),
        a: 5.0,
        b: 3.0,
    };

    let output = handler.handle(input).await.unwrap();
    assert_eq!(output.result, 8.0);
}</code></pre>
<p><strong>What it tests</strong>:</p>
<ul>
<li>Basic addition works</li>
<li>Input deserialization</li>
<li>Output serialization</li>
<li>Handler trait implementation</li>
</ul>
<p><strong>Edge cases NOT tested</strong> (intentionally):</p>
<ul>
<li>Float precision (5.1 + 3.2 = 8.3)</li>
<li>Large numbers (handled by f64)</li>
<li>Negative numbers (subtraction tests this)</li>
</ul>
<p><strong>Why 5.0 + 3.0 = 8.0?</strong></p>
<p>Simple numbers avoid floating-point precision issues. This is a <strong>smoke test</strong>, not a numerical analysis test.</p>
<h3 id="test-2-subtraction-happy-path"><a class="header" href="#test-2-subtraction-happy-path">Test 2: Subtraction (Happy Path)</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_subtract() {
    let handler = CalculateHandler;
    let input = CalculateInput {
        operation: "subtract".to_string(),
        a: 10.0,
        b: 3.0,
    };

    let output = handler.handle(input).await.unwrap();
    assert_eq!(output.result, 7.0);
}</code></pre>
<p><strong>What it adds</strong>:</p>
<ul>
<li>Pattern matching works for second branch</li>
<li>Negative results possible (if a &lt; b)</li>
</ul>
<p><strong>Design choice</strong>: 10.0 - 3.0 (positive result) instead of 3.0 - 10.0 (negative result). Either works, we chose simplicity.</p>
<h3 id="test-3-multiplication-happy-path"><a class="header" href="#test-3-multiplication-happy-path">Test 3: Multiplication (Happy Path)</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_multiply() {
    let handler = CalculateHandler;
    let input = CalculateInput {
        operation: "multiply".to_string(),
        a: 4.0,
        b: 5.0,
    };

    let output = handler.handle(input).await.unwrap();
    assert_eq!(output.result, 20.0);
}</code></pre>
<p><strong>What it adds</strong>:</p>
<ul>
<li>Third pattern match branch</li>
<li>Result larger than inputs</li>
</ul>
<p><strong>Why 4.0 * 5.0?</strong></p>
<p>Clean result (20.0) without precision issues.</p>
<h3 id="test-4-division-happy-path"><a class="header" href="#test-4-division-happy-path">Test 4: Division (Happy Path)</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_divide() {
    let handler = CalculateHandler;
    let input = CalculateInput {
        operation: "divide".to_string(),
        a: 15.0,
        b: 3.0,
    };

    let output = handler.handle(input).await.unwrap();
    assert_eq!(output.result, 5.0);
}</code></pre>
<p><strong>What it adds</strong>:</p>
<ul>
<li>Division operation works</li>
<li>Non-zero denominator case</li>
</ul>
<p><strong>Deliberately tests happy path</strong> - error path comes next.</p>
<h3 id="test-5-division-by-zero-error-path"><a class="header" href="#test-5-division-by-zero-error-path">Test 5: Division by Zero (Error Path)</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_divide_by_zero() {
    let handler = CalculateHandler;
    let input = CalculateInput {
        operation: "divide".to_string(),
        a: 10.0,
        b: 0.0,
    };

    let result = handler.handle(input).await;
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Division by zero"));
}</code></pre>
<p><strong>Critical differences</strong>:</p>
<ul>
<li>NO <code>.unwrap()</code> - we expect an error</li>
<li><code>assert!(result.is_err())</code> - verify error occurred</li>
<li><code>.unwrap_err()</code> - extract error for message validation</li>
<li><code>.contains()</code> - verify error message content</li>
</ul>
<p><strong>Why check error message?</strong></p>
<p>Ensures users get <strong>actionable feedback</strong>, not just “error occurred.”</p>
<h3 id="test-6-unknown-operation-error-path"><a class="header" href="#test-6-unknown-operation-error-path">Test 6: Unknown Operation (Error Path)</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_unknown_operation() {
    let handler = CalculateHandler;
    let input = CalculateInput {
        operation: "modulo".to_string(),
        a: 10.0,
        b: 3.0,
    };

    let result = handler.handle(input).await;
    assert!(result.is_err());
    assert!(result
        .unwrap_err()
        .to_string()
        .contains("Unknown operation"));
}</code></pre>
<p><strong>What it validates</strong>:</p>
<ul>
<li>Input validation works</li>
<li>Catch-all match arm triggered</li>
<li>Helpful error message provided</li>
</ul>
<p><strong>Why “modulo”?</strong></p>
<p>Realistic invalid operation that users might try.</p>
<h2 id="test-coverage-analysis"><a class="header" href="#test-coverage-analysis">Test Coverage Analysis</a></h2>
<p>Run coverage with:</p>
<pre><code class="language-bash">cargo tarpaulin --out Stdout
</code></pre>
<p><strong>Expected output</strong>:</p>
<pre><code>|| Tested/Total Lines:
|| src/handlers.rs: 45/45 (100%)
||
|| Coverage: 100.00%
</code></pre>
<h3 id="coverage-breakdown"><a class="header" href="#coverage-breakdown">Coverage Breakdown</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code Path</th><th>Test</th><th>Coverage</th></tr></thead><tbody>
<tr><td>CalculateInput struct</td><td>All</td><td>✅</td></tr>
<tr><td>CalculateOutput struct</td><td>All</td><td>✅</td></tr>
<tr><td>Handler trait impl</td><td>All</td><td>✅</td></tr>
<tr><td>“add” branch</td><td>test_add</td><td>✅</td></tr>
<tr><td>“subtract” branch</td><td>test_subtract</td><td>✅</td></tr>
<tr><td>“multiply” branch</td><td>test_multiply</td><td>✅</td></tr>
<tr><td>“divide” branch</td><td>test_divide</td><td>✅</td></tr>
<tr><td>Division by zero error</td><td>test_divide_by_zero</td><td>✅</td></tr>
<tr><td>Unknown operation error</td><td>test_unknown_operation</td><td>✅</td></tr>
</tbody></table>
</div>
<p><strong>100% line coverage. 100% branch coverage.</strong></p>
<h2 id="running-the-tests"><a class="header" href="#running-the-tests">Running the Tests</a></h2>
<h3 id="basic-test-run"><a class="header" href="#basic-test-run">Basic Test Run</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>running 6 tests
test tests::test_add ... ok
test tests::test_subtract ... ok
test tests::test_multiply ... ok
test tests::test_divide ... ok
test tests::test_divide_by_zero ... ok
test tests::test_unknown_operation ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p><strong>All tests pass in &lt;10ms</strong>. This is <strong>FAST</strong>.</p>
<h3 id="verbose-output"><a class="header" href="#verbose-output">Verbose Output</a></h3>
<pre><code class="language-bash">cargo test -- --nocapture
</code></pre>
<p>Shows println! output (though we don’t use it).</p>
<h3 id="single-test"><a class="header" href="#single-test">Single Test</a></h3>
<pre><code class="language-bash">cargo test test_divide_by_zero
</code></pre>
<p>Runs only the division by zero test.</p>
<h3 id="watch-mode"><a class="header" href="#watch-mode">Watch Mode</a></h3>
<pre><code class="language-bash">cargo watch -x test
</code></pre>
<p>Runs tests automatically on file save. <strong>Perfect for EXTREME TDD</strong>.</p>
<h2 id="test-performance"><a class="header" href="#test-performance">Test Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Test</th><th>Time</th><th>Allocations</th></tr></thead><tbody>
<tr><td>test_add</td><td>&lt;1ms</td><td>0</td></tr>
<tr><td>test_subtract</td><td>&lt;1ms</td><td>0</td></tr>
<tr><td>test_multiply</td><td>&lt;1ms</td><td>0</td></tr>
<tr><td>test_divide</td><td>&lt;1ms</td><td>0</td></tr>
<tr><td>test_divide_by_zero</td><td>&lt;1ms</td><td>1 (error String)</td></tr>
<tr><td>test_unknown_operation</td><td>&lt;1ms</td><td>1 (error String)</td></tr>
</tbody></table>
</div>
<p><strong>Total test suite runtime</strong>: 3ms</p>
<p><strong>Why so fast?</strong></p>
<ol>
<li>No I/O operations</li>
<li>No network calls</li>
<li>No file system access</li>
<li>Pure computation</li>
<li>Optimized by Rust compiler</li>
</ol>
<h2 id="extreme-tdd-test-first-development"><a class="header" href="#extreme-tdd-test-first-development">EXTREME TDD: Test-First Development</a></h2>
<p>These tests were written <strong>before</strong> the handler code:</p>
<h3 id="the-red-green-refactor-loop"><a class="header" href="#the-red-green-refactor-loop">The RED-GREEN-REFACTOR Loop</a></h3>
<p><strong>Cycle 1</strong>: test_add</p>
<ul>
<li>RED: Write test → Fails (handler doesn’t exist)</li>
<li>GREEN: Write minimal handler → Passes</li>
<li>REFACTOR: Extract match pattern → Still passes</li>
<li>COMMIT: Quality gates pass ✅</li>
</ul>
<p><strong>Cycle 2</strong>: test_subtract</p>
<ul>
<li>RED: Write test → Fails (only “add” implemented)</li>
<li>GREEN: Add “subtract” branch → Passes</li>
<li>REFACTOR: Run clippy → No issues</li>
<li>COMMIT: Quality gates pass ✅</li>
</ul>
<p><strong>Pattern repeats for all 6 tests.</strong></p>
<h3 id="time-investment"><a class="header" href="#time-investment">Time Investment</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Time</th></tr></thead><tbody>
<tr><td>Writing tests</td><td>10 minutes</td></tr>
<tr><td>Writing handler</td><td>8 minutes</td></tr>
<tr><td>Refactoring</td><td>2 minutes</td></tr>
<tr><td><strong>Total</strong></td><td><strong>20 minutes</strong></td></tr>
</tbody></table>
</div>
<p><strong>20 minutes to production-ready code</strong> with 100% coverage.</p>
<h2 id="test-driven-design-benefits"><a class="header" href="#test-driven-design-benefits">Test Driven Design Benefits</a></h2>
<h3 id="1-simpler-apis"><a class="header" href="#1-simpler-apis">1. Simpler APIs</a></h3>
<p>Tests forced us to design:</p>
<ul>
<li>Single tool instead of four</li>
<li>Clear input/output structs</li>
<li>Meaningful error messages</li>
</ul>
<h3 id="2-comprehensive-coverage"><a class="header" href="#2-comprehensive-coverage">2. Comprehensive Coverage</a></h3>
<p>Writing tests first means:</p>
<ul>
<li>No untested code paths</li>
<li>Edge cases considered upfront</li>
<li>Error handling built-in</li>
</ul>
<h3 id="3-regression-protection"><a class="header" href="#3-regression-protection">3. Regression Protection</a></h3>
<p>All 6 tests run on every commit:</p>
<ul>
<li>Pre-commit hooks prevent breaks</li>
<li>CI/CD catches integration issues</li>
<li>Refactoring is safe</li>
</ul>
<h3 id="4-living-documentation"><a class="header" href="#4-living-documentation">4. Living Documentation</a></h3>
<p>Tests show <strong>how to use</strong> the handler:</p>
<pre><code class="language-rust">// Want to add two numbers?
let input = CalculateInput {
    operation: "add".to_string(),
    a: 5.0,
    b: 3.0,
};
let result = handler.handle(input).await?;
// result.result == 8.0</code></pre>
<h2 id="testing-anti-patterns-what-we-avoid"><a class="header" href="#testing-anti-patterns-what-we-avoid">Testing Anti-Patterns (What We AVOID)</a></h2>
<h3 id="anti-pattern-1-testing-implementation"><a class="header" href="#anti-pattern-1-testing-implementation">Anti-Pattern 1: Testing Implementation</a></h3>
<pre><code class="language-rust">// WRONG - tests implementation details
#[test]
fn test_match_expression() {
    // Don't test how it's implemented, test what it does
}</code></pre>
<h3 id="anti-pattern-2-over-mocking"><a class="header" href="#anti-pattern-2-over-mocking">Anti-Pattern 2: Over-Mocking</a></h3>
<pre><code class="language-rust">// WRONG - unnecessary mocking
let mock_handler = MockHandler::new();
mock_handler.expect_add().returning(|a, b| a + b);</code></pre>
<p>Our handler is pure logic - no mocks needed.</p>
<h3 id="anti-pattern-3-one-assertion-per-test"><a class="header" href="#anti-pattern-3-one-assertion-per-test">Anti-Pattern 3: One Assertion Per Test</a></h3>
<pre><code class="language-rust">// WRONG - too granular
#[test]
fn test_output_has_result_field() {
    let output = CalculateOutput { result: 8.0 };
    assert!(output.result == 8.0);  // Useless test
}</code></pre>
<p>Test <strong>behavior</strong>, not structure.</p>
<h3 id="anti-pattern-4-testing-the-framework"><a class="header" href="#anti-pattern-4-testing-the-framework">Anti-Pattern 4: Testing the Framework</a></h3>
<pre><code class="language-rust">// WRONG - testing serde
#[test]
fn test_input_deserializes() {
    let json = r#"{"operation":"add","a":5,"b":3}"#;
    let input: CalculateInput = serde_json::from_str(json).unwrap();
    // Don't test third-party libraries
}</code></pre>
<p>Trust serde. Test <strong>your code</strong>.</p>
<h2 id="quality-gates-integration"><a class="header" href="#quality-gates-integration">Quality Gates Integration</a></h2>
<p>Tests run as part of quality gates:</p>
<pre><code class="language-bash">make quality-gate
</code></pre>
<p><strong>Checks</strong>:</p>
<ol>
<li><code>cargo test</code> - All tests pass ✅</li>
<li><code>cargo tarpaulin</code> - Coverage ≥80% ✅ (we have 100%)</li>
<li><code>cargo clippy</code> - No warnings ✅</li>
<li><code>cargo fmt --check</code> - Formatted ✅</li>
<li><code>pmat analyze complexity</code> - Complexity ≤20 ✅</li>
</ol>
<p><strong>If ANY gate fails, commit is blocked.</strong></p>
<h2 id="continuous-testing"><a class="header" href="#continuous-testing">Continuous Testing</a></h2>
<p>During development, run:</p>
<pre><code class="language-bash">cargo watch -x 'test --lib --quiet' -x 'clippy --quiet'
</code></pre>
<p><strong>Feedback loop</strong>:</p>
<ol>
<li>Save file</li>
<li>Tests run (3ms)</li>
<li>Clippy runs (200ms)</li>
<li>Results shown</li>
<li><strong>Total: &lt;300ms feedback</strong></li>
</ol>
<p>This is the <strong>5-minute cycle in action</strong> - fast feedback enables rapid iteration.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand the testing philosophy, let’s run the calculator server and use it in Chapter 3.4. You’ll see how these tests translate to production confidence.</p>
<hr />
<blockquote>
<p>“Tests are not just verification - they’re the design process.” - EXTREME TDD principle</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-02-handler.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-04-running.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-02-handler.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-04-running.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
